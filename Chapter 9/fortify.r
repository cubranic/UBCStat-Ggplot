library(ggplot2)

# ggplot() is typically designed for visualizing data stored as `data.frame`.
# To apply ggplot() to other types of R object, such as the plot() method
# for `lm` class, it is through the fortify() method.

# The fortify() method prepares an R object to be suitable for visualizing
# using ggplot().

# fortify() method for `lm` objects just adds extra variables to the original
# data set for model diagnostics.
ggplot2:::fortify.lm
mod <- lm(cty ~ displ, mpg)
head(fortify(mod))

# The diagnostic plots can be generated by the plot() method for `lm` class,
# but the plots are not very customizable.

# Windows users use windows()
X11(); X11()

# The plot of residual versus fitted value
dev.set(2)
plot(mod, which = 1)

dev.set(3)
ggplot(mod, aes(.fitted, .resid)) +
  geom_hline(yintercept = 0, color = "grey50", size = 0.5) +
  geom_point() +
  geom_smooth(size = 0.5, se = FALSE, color = "red")

# Normal Q-Q plot of standard residuals
dev.set(2)
plot(mod, which = 2)

dev.set(3)
slope <- diff(quantile(rstandard(mod), c(0.25, 0.75))) /
           diff(qnorm(c(0.25, 0.75)))
ggplot(mod, aes(sample = .stdresid)) + stat_qq() +
  labs(x = "Theoretical Quantiles", y = "Standard residuals",
       title = "Normal Q-Q") +
  geom_abline(slope = slope, linetype = "longdash",
              size = 0.8, color = "gray50")

# The plot of Cook's distance vs Leverage / (1 - Leverage)
dev.set(2)
plot(mod, which = 6)

dev.set(3)
breaks <- pretty(influence(mod)$hat)
ggplot(mod, aes(.hat / (1 - .hat), .cooksd)) +
  labs(title = expression("Cook's dist vs Leverage " * h[ii] / (1 - h[ii])),
       x = expression("Leverage " * h[ii]), y = "Cook's distance") +
  scale_x_continuous(breaks = breaks / (1 - breaks), labels = breaks) +
  geom_vline(xintercept = 0, color = "white") +
  geom_abline(slope = (0:6)^2, color = "gray50",
              linetype = "longdash", size = 0.8) +
  geom_smooth(se = FALSE) +
  geom_point()

################################################
## Create fortify() method for new classes
################################################
# Original geom_smooth() adds the confidence band
dev.set(2)
ggplot(mpg, aes(displ, cty)) +
  geom_smooth(method = "loess", se = TRUE, color = "darkblue", size = 1) +
  geom_point()

# What if we want to add the prediction band instead?
# The standard errors will be different (larger).

mod1 <- loess(cty ~ displ, mpg)

# fortify() method for `loess` object to create necessary variables for
# plotting the prediction band
fortify.loess <- function (model, ...) {
  # Extract the original data set
  data <- data.frame(model$y, model$x)
  names(data) <- all.vars(formula(model))

  pred <- predict(model, se = TRUE)
  data$.fitted <- pred$fit # fitted value
  data$.se <- sqrt(pred$se^2 + pred$residual.scale^2) # standard error of prediction
  data
}

dev.set(3)
ggplot(mod1, aes(displ, cty)) +
  geom_line(aes(displ, .fitted), col = "darkblue", size = 1) +
  geom_ribbon(aes(ymin = .fitted - 2 * .se, ymax = .fitted + 2 * .se),
              fill = "darkblue", alpha = 0.4) +
  geom_add_se(mod1) +
  geom_point()


# Conclusion: you can apply ggplot() to an R object of any class
# through customized fortify() method for that class.
# In my opinion, unless you can see the same figures will be generated
# repeatedly in the future, there is no need to define a fortify() method.
